Xend = 1:choose(d,2) + 0.4,
Yend = y0s,
Group = c("typeA"),
color = c("red"))
bp_mle_SPE <- ggplot(data = data_longformat,aes(x=data_longformat$Var2,y=data_longformat$value,fill=data_longformat$Var1)) +
geom_boxplot() +
labs(title="",x="", y = "") +
scale_fill_manual(labels=c(expression(T[1]),expression(T[2]),expression(T[3]),expression(T[4])),values=c("lightskyblue","lightgreen","lavender","papayawhip")) +
# legend labels
theme(legend.title = element_blank(),
legend.text = element_text(face="bold", size=15),
legend.key.size = unit(1, 'cm'),
legend.position="none",
aspect.ratio = 1,
axis.text.x = element_text(color="black", face="bold", size=9, angle = 20, hjust = 0.5),
axis.text.y = element_text(face="bold", size=9),
panel.background = element_rect(fill = "white",
colour = "white",
linewidth = 0.5, linetype = "solid"),
panel.grid.major = element_line(linewidth = 0.5, linetype = 'solid',
colour = "grey"),
panel.grid.minor = element_line(linewidth = 0.25, linetype = 'solid',
colour = "grey"),
plot.margin = margin(0, 1, 0, 0, "cm")) +
scale_y_continuous(breaks = seq(-1,4,1),limits = c(-1,4,1)) +
geom_segment(data = dLines, color = "red",aes(x = dLines$X, y = dLines$Y, xend = dLines$Xend, yend=dLines$Yend), inherit.aes = FALSE) +
scale_x_discrete(labels=c(expression(atop(chi[12],"\n(HR)")),expression(atop(chi[23],"\n(NL)"))
,expression(atop(chi[24],"\n(L)")),expression(atop(chi[45],"\n(Diri)"))
,expression(atop(tau[13~";"~2],"\n(Clay)")),expression(atop(tau[34~";"~2],"\n(Gum)"))
,expression(atop(tau[25~";"~4],"\n(Ga)")),expression(atop(tau[14~";"~23],"\n(Clay)"))
,expression(atop(tau[35~";"~24],"\n(Ga)")),expression(atop(tau[15~";"~234],"\n(Ga)"))))
bp_mle_SPE
Var1<-Var2<-value<-X<-Y<-Xend<-Yend<-NULL
##  Create boxplots
##  1. MLE via sequential parameter estimation (SPE)
all.pairs <- combn(1:d, 2)
MLest4eachpair=apply(all.pairs, 2, function(ind) rbind(MLE_WithoutFamSel[ind[1],ind[2],]))
data_longformat=melt(MLest4eachpair)
for(i in 1:(d-1)){
a=cumsum((d-1):1)
b=cumsum((d-1):1)+1
if(i==1){
data_longformat$Var1[data_longformat$Var2%in%(1:a[i])]=1
}else{
data_longformat$Var1[data_longformat$Var2%in%(b[i-1]:a[i])]=i
}
}
data_longformat$Var1 <- as.character(data_longformat$Var1)
data_longformat$Var2 <- as.factor(data_longformat$Var2)
TrueMtx=t(XVS$pmat[,,1]) # Specified MLEs
y0s <- c(TrueMtx[lower.tri(TrueMtx)])
dLines <- data.frame(X =1:choose(d,2) - 0.4,
Y = y0s,
Xend = 1:choose(d,2) + 0.4,
Yend = y0s,
Group = c("typeA"),
color = c("red"))
bp_mle_SPE <- ggplot(data = data_longformat,aes(x=Var2,y=value,fill=Var1)) +
geom_boxplot() +
labs(title="",x="", y = "") +
scale_fill_manual(labels=c(expression(T[1]),expression(T[2]),expression(T[3]),expression(T[4])),values=c("lightskyblue","lightgreen","lavender","papayawhip")) +
# legend labels
theme(legend.title = element_blank(),
legend.text = element_text(face="bold", size=15),
legend.key.size = unit(1, 'cm'),
legend.position="none",
aspect.ratio = 1,
axis.text.x = element_text(color="black", face="bold", size=9, angle = 20, hjust = 0.5),
axis.text.y = element_text(face="bold", size=9),
panel.background = element_rect(fill = "white",
colour = "white",
linewidth = 0.5, linetype = "solid"),
panel.grid.major = element_line(linewidth = 0.5, linetype = 'solid',
colour = "grey"),
panel.grid.minor = element_line(linewidth = 0.25, linetype = 'solid',
colour = "grey"),
plot.margin = margin(0, 1, 0, 0, "cm")) +
scale_y_continuous(breaks = seq(-1,4,1),limits = c(-1,4,1)) +
geom_segment(data = dLines, color = "red",aes(x = X, y = Y, xend = Xend, yend=Yend), inherit.aes = FALSE) +
scale_x_discrete(labels=c(expression(atop(chi[12],"\n(HR)")),expression(atop(chi[23],"\n(NL)"))
,expression(atop(chi[24],"\n(L)")),expression(atop(chi[45],"\n(Diri)"))
,expression(atop(tau[13~";"~2],"\n(Clay)")),expression(atop(tau[34~";"~2],"\n(Gum)"))
,expression(atop(tau[25~";"~4],"\n(Ga)")),expression(atop(tau[14~";"~23],"\n(Clay)"))
,expression(atop(tau[35~";"~24],"\n(Ga)")),expression(atop(tau[15~";"~234],"\n(Ga)"))))
bp_mle_SPE
ggplot(data = data_longformat,aes(x=Var2,y=value,fill=Var1)) +
geom_boxplot()
ggplot(data = data_longformat,aes(x=Var2,y=value,fill=Var1)) +
geom_boxplot() +
labs(title="",x="", y = "") +
scale_fill_manual(labels=c(expression(T[1]),expression(T[2]),expression(T[3]),expression(T[4])),values=c("lightskyblue","lightgreen","lavender","papayawhip"))
ggplot(data = data_longformat,aes(x=Var2,y=value,fill=Var1)) +
geom_boxplot()
##  Create boxplots
##  1. MLE via sequential parameter estimation (SPE)
all.pairs <- combn(1:d, 2)
MLest4eachpair=apply(all.pairs, 2, function(ind) rbind(MLE_WithoutFamSel[ind[1],ind[2],]))
data_longformat=melt(MLest4eachpair)
for(i in 1:(d-1)){
a=cumsum((d-1):1)
b=cumsum((d-1):1)+1
if(i==1){
data_longformat$Var1[data_longformat$Var2%in%(1:a[i])]=1
}else{
data_longformat$Var1[data_longformat$Var2%in%(b[i-1]:a[i])]=i
}
}
data_longformat$Var1 <- as.character(data_longformat$Var1)
data_longformat$Var2 <- as.factor(data_longformat$Var2)
bp_mle_SPE <- ggplot(data = data_longformat,aes(x=Var2,y=value,fill=Var1)) +
geom_boxplot() +
labs(title="",x="", y = "")
bp_mle_SPE
load_all()
check()
BoxOut2K05=XVineBoxplot(N = 500, qt = 0.05, ite = ite, XVS = XVS, RankT = TRUE)
FamSelSimulation
use_r("XVineFamSelSimul")
d <- dim(XVS$xmat)[1]
EdgeTotal=sum(1:(d-1))
FamSelOut <- list()
##  Repeat generating Pareto samples and performing family selections
for(i in 1:ite){
Dat_P=ParetoSim(n = N, XVS = XVS)
FamSelOut[[i]] <- XVineFamSel(data = Dat_P, Rank = Rank, qt = qt, XVS = XVS, famset_tc = familyset_tc, famset_cop = familyset_cop
, selectioncrit = selectioncrit,effsampsize = effsampsize, tau_threshold = tau_threshold)
}
Rank=TRUE
##  Repeat generating Pareto samples and performing family selections
for(i in 1:ite){
Dat_P=ParetoSim(n = N, XVS = XVS)
FamSelOut[[i]] <- XVineFamSel(data = Dat_P, Rank = Rank, qt = qt, XVS = XVS, famset_tc = familyset_tc, famset_cop = familyset_cop
, selectioncrit = selectioncrit,effsampsize = effsampsize, tau_threshold = tau_threshold)
}
selectioncrit = 'AIC'
effsampsize = 10
tau_threshold = 0.05
##  Repeat generating Pareto samples and performing family selections
for(i in 1:ite){
Dat_P=ParetoSim(n = N, XVS = XVS)
FamSelOut[[i]] <- XVineFamSel(data = Dat_P, Rank = Rank, qt = qt, XVS = XVS, famset_tc = familyset_tc, famset_cop = familyset_cop
, selectioncrit = selectioncrit,effsampsize = effsampsize, tau_threshold = tau_threshold)
}
FamSelOut
EffSizeComb=lapply(1:ite, function(i)FamSelOut[[i]]$EffectSamp)
EffSizeComb
FamSelOut
EffSizeComb=array(unlist(EffSizeComb),dim=c(d,d,ite))
EffSizeComb
apply(X = EffSizeComb, c(1,2), function(x) mean(x,na.rm=T))
((d-1):1)*(ite)
(d-1):1
apply(X = CountComb, c(1,2), function(x) mean(x,na.rm=T))
##  3. Proportion of correctly selected families for each edge in each tree
EdgeProp=apply(X = CountComb, c(1,2), function(x) mean(x,na.rm=T))
##  1. Proportion of correctly selected families over all trees
CountComb=lapply(1:ite,function(i)FamSelOut[[i]]$count)
##  3. Proportion of correctly selected families for each edge in each tree
EdgeProp=apply(X = CountComb, c(1,2), function(x) mean(x,na.rm=T))
CountComb
apply(X = CountComb, c(1,2), function(x) mean(x,na.rm=T))
CountComb=array(unlist(CountComb),dim=c(dim(XVS$xmat)[1],dim(XVS$xmat)[1],ite))
##  3. Proportion of correctly selected families for each edge in each tree
EdgeProp=apply(X = CountComb, c(1,2), function(x) mean(x,na.rm=T))
EdgeProp
EdgeProp[EdgeProp=="NaN"]=0
EdgeProp
##  4. How many times the algorithm selects the independence copula for a specific edge
FamComb=lapply(1:ite,function(i)FamSelOut[[i]]$famsel)
FamComb=array(unlist(FamComb),dim=c(d,d,ite))
SelectIndCop=sum(FamComb[edge_index[1],edge_index[2],]==0)/ite
edge_index=c(4,5)
SelectIndCop=sum(FamComb[edge_index[1],edge_index[2],]==0)/ite
SelectIndCop
EffSizePercent
##  Extract the effective sample size matrices
EffSizeComb=lapply(1:ite, function(i)FamSelOut[[i]]$EffectSamp)
EffSizeComb=array(unlist(EffSizeComb),dim=c(d,d,ite))
##  Convert to the percentage of effective sample size with respect to the sample size N
Avg.EffectSize=apply(X = EffSizeComb, c(1,2), function(x) mean(x,na.rm=T))
EffSizePercent=(Avg.EffectSize/N)*100 # percentages of effective sample size
##  1. Proportion of correctly selected families over all trees
CountComb=lapply(1:ite,function(i)FamSelOut[[i]]$count)
CountComb=array(unlist(CountComb),dim=c(dim(XVS$xmat)[1],dim(XVS$xmat)[1],ite))
GlobalProp=sum(apply(X = CountComb,c(1,2),function(x)sum(x)),na.rm = T)/(EdgeTotal*ite)
##  2. The overall proportion of correctly selected families for each tree level
Num=((d-1):1)*(ite)
TreeProp=rowSums(apply(X = CountComb,c(1,2),function(x)sum(x)),na.rm=T)[1:(d-1)]/Num
##  3. Proportion of correctly selected families for each edge in each tree
EdgeProp=apply(X = CountComb, c(1,2), function(x) mean(x,na.rm=T))
##  4. How many times the algorithm selects the independence copula for a specific edge
FamComb=lapply(1:ite,function(i)FamSelOut[[i]]$famsel)
FamComb=array(unlist(FamComb),dim=c(d,d,ite))
SelectIndCop=sum(FamComb[edgeIndex[1],edgeIndex[2],]==0)/ite
edgeIndex=c(4,5)
SelectIndCop=sum(FamComb[edgeIndex[1],edgeIndex[2],]==0)/ite
FamSelOut
EffSizePercent
GlobalProp
TreeProp
EdgeProp
SelectIndCop
load_all()
check()
load_all()
check()
load_all()
check()
load_all()
check()
load_all()
check()
use_r("XVineModelFit.R")
use_r("TreeCrit.R")
?VineCopula:::set_treecrit
VineCopula:::set_treecrit
MST_HR
VineCopula:::findMaxTree
data2mpareto
for(i in 2:1)
{print(i)}
d >= 2
d
d >= 2
onlyif(d>=2)
trunclevel
use_r("tcFamSel.R")
use_r("pcFamSel.R")
CondTC
BiCopEst
use_r("fit.FirstTree.R")
StrMtx <- matrix(c(1, 1, 2, 2, 4,
0, 2, 1, 3, 2,
0, 0, 3, 1, 3,
0, 0, 0, 4, 1,
0, 0, 0, 0, 5),5,byrow = TRUE)
ParMtx <- matrix(c(0, 1.5, 2, 2.5, 2,
0, 0, 2, 2.5, 0.7,
0, 0, 0, 0.4, -0.3,
0, 0, 0, 0, 0.1,
0, 0, 0, 0, 0),5,byrow = TRUE)
FamMtx <- matrix(c(0, 1, 2, 3, 4,
0, 0, 3, 4, 1,
0, 0, 0, 3, 1,
0, 0, 0, 0, 1,
0, 0, 0, 0, 0),5,byrow = TRUE)
# X-vine specification
XVS=XVineSpec(M = StrMtx, Mmod = FamMtx, Mpar = ParMtx)
# Pareto random samples
Dat_P=ParetoSim(n = 2000, XVS = XVS) # Pareto scale
data=1/Dat_P
# Determine the truncation level if specified.
d <- ifelse(test = trunclevel,trunclevel+1,ncol(data))
trunclevel = FALSE
# Determine the truncation level if specified.
d <- ifelse(test = trunclevel,trunclevel+1,ncol(data))
d
d_col <- ncol(data)
d_col
n <- nrow(data)
n
treecritT1 = "chi", treecritT2= 'tau'
treecritT1 = "chi"
treecritT2= 'tau'
# Determine the selection criteria for T_1 and T_i, i=2,...
T1crit <- TreeCrit(treecrit = treecritT1)
Ticrit <- TreeCrit(treecrit = treecritT2)
load_all()
# Determine the selection criteria for T_1 and T_i, i=2,...
T1crit <- TreeCrit(treecrit = treecritT1)
Ticrit <- TreeCrit(treecrit = treecritT2)
#Ticrit <- VineCopula:::set_treecrit(treecrit = treecritT2)
# Set NULL lists
MST <- list()
VineTree=list()
weights=NA
cores = 1
tau_threshold=0.05
effsampsize=10
si=0.9
progress = TRUE
g <- VineCopula:::initializeFirstGraph(data, T1crit, weights)
g
MST[[1]] <- VineCopula:::findMaxTree(g, mode = "RVine")
MST
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, se = se, cores = 1)
se=FALSE
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, cores = 1)
load_all()
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, cores = 1)
(
load_all()
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, cores = 1)
load_all()
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, cores = 1)
tcfamset = c(1,2,3,4)
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, cores = 1)
VineTree
str(VineTree)
tree=2
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
VineCopula:::buildNextGraph
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
VineCopula:::set_treecrit(treecrit = treecritT2)
TreeCrit(treecrit = treecritT2)
#'
#' @param treecrit A function that includes three arguments (u1,u2,weights). The first two arguments are for bivariate parametric models and the last argument 'weights' can be
#' used for weighting missing values.
#' @param famset A numeric vector; the list of families for pair-copula models.
#'
#' @return The defined function `treecrit` used to calculate edge weights.
#' @export
#'
#' @examples
#' TreeCrit('chi')
TreeCrit <- function(treecrit, famset){
#'
#' @param treecrit A function that includes three arguments (u1,u2,weights). The first two arguments are for bivariate parametric models and the last argument 'weights' can be
#' used for weighting missing values.
#' @param famset A numeric vector; the list of families for pair-copula models.
#'
#' @return The defined function `treecrit` used to calculate edge weights.
#' @export
#'
#' @examples
#' TreeCrit('chi')
TreeCrit <- function(treecrit, famset){
load_all()
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
g
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
VineCopula:::fasttau
Ticrit <- TreeCrit(treecrit = treecritT2)
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
Ticrit
load_all()
tcFamSel()
tcFamSel
TreeCrit
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
Ticrit
treecritT2
Ticrit <- TreeCrit(treecrit = treecritT2)
Ticrit
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
g
MST[[tree]] <- VineCopula:::findMaxTree(g, mode = "RVine", truncated = FALSE)
MST
MST[[tree]]
se
use_r("fit.SubTree.R")
use_r("Condfit.SecondTree.R")
library(devtools)
use_r("Condfit.SecondTree.R")
use_r("Condfit.SubTree.R")
use_r("pseudo.ite.R")
use_r("Condfit.FirstTree.R")
StrMtx <- matrix(c(1, 1, 2, 2, 4,
0, 2, 1, 3, 2,
0, 0, 3, 1, 3,
0, 0, 0, 4, 1,
0, 0, 0, 0, 5),5,byrow = TRUE)
ParMtx <- matrix(c(0, 1.5, 2, 2.5, 2,
0, 0, 2, 2.5, 0.7,
0, 0, 0, 0.4, -0.3,
0, 0, 0, 0, 0.1,
0, 0, 0, 0, 0),5,byrow = TRUE)
FamMtx <- matrix(c(0, 1, 2, 3, 4,
0, 0, 3, 4, 1,
0, 0, 0, 3, 1,
0, 0, 0, 0, 1,
0, 0, 0, 0, 0),5,byrow = TRUE)
# X-vine specification
XVS=XVineSpec(M = StrMtx, Mmod = FamMtx, Mpar = ParMtx)
load_all()
# X-vine specification
XVS=XVineSpec(M = StrMtx, Mmod = FamMtx, Mpar = ParMtx)
# Pareto random samples
Dat_P=ParetoSim(n = 2000, XVS = XVS) # Pareto scale
data=1/Dat_P
Rank=TRUE
tcfamset = c(1,2,3,4)
treecritT1 = "chi"
treecritT2= 'tau'
si=0.9
effsampsize=10
tau_threshold=0.05
se=FALSE
weights=NA
cores = 1
progress = TRUE
selectioncrit = "AIC"
trunclevel = FALSE
# Determine the truncation level if specified.
d <- ifelse(test = trunclevel,trunclevel+1,ncol(data))
d
d_col <- ncol(data)
n <- nrow(data)
# Determine the selection criteria for T_1 and T_i, i=2,...
T1crit <- TreeCrit(treecrit = treecritT1)
Ticrit <- TreeCrit(treecrit = treecritT2)
#Ticrit <- VineCopula:::set_treecrit(treecrit = treecritT2)
# Set NULL lists
MST <- list()
VineTree=list()
g <- VineCopula:::initializeFirstGraph(data, T1crit, weights)
MST[[1]] <- VineCopula:::findMaxTree(g, mode = "RVine")
VineTree[[1]] <- fit.FirstTree(MST[[1]], data, tcfamset, si=si,
selectioncrit = selectioncrit, cores = 1)
MST
VineTree
tree=2
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
MST[[tree]] <- VineCopula:::findMaxTree(g, mode = "RVine", truncated = FALSE)
VineTree[[tree]] <- fit.SubTree(data = data, MST = MST, VineTree = VineTree, copfamset = pcfamset, tree = tree, si=si,
selectioncrit, progress, effsampsize = effsampsize, tau_threshold = tau_threshold, weights = weights,
se = se, cores = cores)
pcfamset = c(0,1,3,4,5,6,13,14,16)
VineTree[[tree]] <- fit.SubTree(data = data, MST = MST, VineTree = VineTree, copfamset = pcfamset, tree = tree, si=si,
selectioncrit, progress, effsampsize = effsampsize, tau_threshold = tau_threshold, weights = weights,
se = se, cores = cores)
load_all()
VineTree[[tree]] <- fit.SubTree(data = data, MST = MST, VineTree = VineTree, copfamset = pcfamset, tree = tree, si=si,
selectioncrit, progress, effsampsize = effsampsize, tau_threshold = tau_threshold, weights = weights,
se = se, cores = cores)
tree=3
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
MST[[tree]] <- VineCopula:::findMaxTree(g, mode = "RVine", truncated = FALSE)
VineTree[[tree]] <- fit.SubTree(data = data, MST = MST, VineTree = VineTree, copfamset = pcfamset, tree = tree, si=si,
selectioncrit, progress, effsampsize = effsampsize, tau_threshold = tau_threshold, weights = weights,
se = se, cores = cores)
tree=4
g <- VineCopula:::buildNextGraph(VineTree[[tree-1]], weights, treecrit = Ticrit,
cores > 1, truncated = FALSE)
MST[[tree]] <- VineCopula:::findMaxTree(g, mode = "RVine", truncated = FALSE)
VineTree[[tree]] <- fit.SubTree(data = data, MST = MST, VineTree = VineTree, copfamset = pcfamset, tree = tree, si=si,
selectioncrit, progress, effsampsize = effsampsize, tau_threshold = tau_threshold, weights = weights,
se = se, cores = cores)
load_all()
check()
usethis::use_import_from("VineCopula", "buildNextGraph")
usethis::use_import_from("VineCopula", "fasttau")
usethis::use_import_from("VineCopula", "buildNextGraph")
usethis::use_import_from("VineCopula", "fasttau")
usethis::use_import_from("VineCopula", "findMaxTree")
usethis::use_import_from("VineCopula", "initializeFirstGraph")
usethis::use_import_from("stats","runif")
warnings()
load_all()
check()
load_all()
rm("buildNextGraph",envir = .GlobalEnv)
rm("buildNextGraph",envir = .Xvine)
?rm
load_all()
check()
check()
load_all()
load_all()
load_all()
library(devtools)
load_all()
load_all()
check()
load_all()
check()
load_all()
load_all()
check()
use_r("InitializeFirstGraph.R")
use_r("fastTau.R")
use_r("findMST.R")
use_r("BuildNextGraph.R")
VineCopula:::buildNextGraph
VineCopula:::findMaxTree
VineCopula:::fasttau
VineCopula:::initializeFirstGraph
rename_files("BuildNextGraph","buildNextGraph")
rename_files("findMST","findMaxTree")
rename_files("fastTau","fasttau")
rename_files("InitializeFirstGraph","initializeFirstgraph")
rename_files("BuildNextGraph","buildNextGraph")
rename_files("fastTau","fasttau")
rename_files("InitializeFirstGraph","initializeFirstgraph")
rename_files("initializeFirstgraph","initializeFirstGraph")
load_all()
initializeFirstGraph
findMaxTree
findMaxTree
VineCopula:::findMaxTree
findMaxTree
load_all()
initializeFirstGraph
use_r("initializeFirstGraph.R")
initializeFirstGraph
load_all()
